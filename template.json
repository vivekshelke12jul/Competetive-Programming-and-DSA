
{

	"sieve of eratosthenes": {
		"prefix": "siv",
		"body": [
			"",
			"vector<int> primes;",
			"",
			"void sieve(){",
				"\tint maxn=100001;",
				"\tvector<bool> vec(maxn, true);",
				"\t",
				"\tfor(int i=2; i*i<maxn; i++ ){",
					"\t\tif(vec[i]){",
						"\t\t\tfor(int j=i*i; j<maxn; j+=i){",
							"\t\t\t\tvec[j]=false;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"",
				"\tfor(int i=2; i<maxn; i++){",
					"\t\tif(vec[i]){",
						"\t\t\tprimes.push_back(i);",
					"\t\t}",
				"\t}",
			"}",
			""
		],
		"description": "Log output to console"
	},

	"knapsack": {
		"prefix": "knapsack",
		"body": [
		  "int knapSack(int W, vi wt, vi v, int n){",
		  "    ",
		  "    vi dp(W+1);",
		  "    for(int i=1; i<=n; i++){            // the indices allowd to be taken",
		  "        for(int w=W; w>=0; w--){        // the weight of knapsack",
		  "            ",
		  "            if(wt[i-1] <= w){",
		  "                dp[w] = max(",
		  "                                dp[w],",
		  "                                v[i-1] + dp[w-wt[i-1]]",
		  "                    );",
		  "            }",
		  "        }",
		  "    }",
		  "    // cout << dp << \"\\n\";",
		  "    return dp[W];",
		  "}",
		  " "
		],
		"description": "space optimised knapsack"
	},

	  "knapsack2": {
		"prefix": "knapsack2",
		"body": [
		  "int knapSack(int W, vi wt, vi v, int n){",
		  "    vvi dp(n+1, vi(W+1));",
		  "    for(int i=1; i<=n; i++){            // the indices allowd to be taken",
		  "        for(int j=1; j<=W; j++){        // the weight of knapsack",
		  "            if(wt[i-1] > j){",
		  "                dp[i][j] = dp[i-1][j];",
		  "            }else{",
		  "                dp[i][j] = max(",
		  "                                dp[i-1][j],",
		  "                                v[i-1] + dp[i-1][j-wt[i-1]]",
		  "                    );",
		  "            }",
		  "        }",
		  "    }// cout << dp << \"\\n\";",
		  "    return dp[n][W];",
		  "}",
		  ""
		],
		"description": " W*n knapsack"
	},
	  "lca": {
		"prefix": "lca",
		"body": [
		  "",
		  "int n; ",
		  "vi parent, level;",
		  "vvi chi, gr;",
		  "",
		  "void dfs(int node, int l){",
		  "    level[node] = l;",
		  "    // int cnt = chi[node].size();",
		  "    for(auto ch: chi[node]){",
		  "        dfs(ch, l+1);",
		  "    }",
		  "}",
		  "",
		  "void build(){",
		  "    for(int i=0; i<11; i++){",
		  "        if(i){",
		  "            for(int j=1; j<=n; j++){",
		  "                gr[i][j] = gr[i-1][gr[i-1][j]];",
		  "            }",
		  "        } else {",
		  "            gr[i].assign(all(parent));",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "int lca(int v, int w){",
		  "    if(level[v] > level[w]){",
		  "        swap(v, w);",
		  "    }",
		  "    ",
		  "    int diff = level[w] - level[v];",
		  "    // cout << diff << \"= diff\\n\";",
		  "    if(diff){",
		  "        for(int i=0; i<11; i++){",
		  "            int mask = (1<<i);",
		  "            if(mask&diff){",
		  "                w = gr[i][w];",
		  "            }",
		  "        }",
		  "    }",
		  "    // after this step level of v and w becomes same;",
		  "    // cout << v << \", \" << w << \"\\n\";",
		  "    if(v == w)return v;",
		  "    ",
		  "    for(int i=10; i>=0; i--){",
		  "        int pv = gr[i][v];",
		  "        int pw = gr[i][w];",
		  "        if(pv != pw){",
		  "            v = pv;",
		  "            w = pw;",
		  "        }",
		  "    }",
		  "    return parent[v];",
		  "}",
		  "// put the below code in main()",
		  "chi.clear();chi.assign(n+1, vi());",
		  "    gr.clear(); gr.assign(11, vi(n+1));         //log(1000) is 9.9, for saafety taken 11;",
		  "    parent.clear();parent.assign(n+1, 0);",
		  "    level.clear();level.assign(n+1, 0);",
		  "    ",
		  "    for(int i=1; i<=n;i++){",
		  "        int cnt; cin>>cnt;",
		  "        for(int j=0; j<cnt; j++){",
		  "            int ch; cin >>ch;",
		  "            chi[i].push_back(ch);",
		  "            parent[ch] = i;",
		  "        }",
		  "    }",
		  "    dfs(1, 1);",
		  "    build();",
		  "    // for(auto v: gr){",
		  "    //     cout << v << \"\\n\";",
		  "    // }cout << \".\\n\";",
		  "    int q;cin>>q;",
		  "    for(int i=0; i<q; i++){",
		  "        int v, w; cin >> v >> w;",
		  "        // cout << \"------------------------\\n\";",
		  "        cout << lca(v, w) << \"\\n\";",
		  "    }"
		],
		"description": "lowest common ancestor"
	},
	"lcs": {
		"prefix": "lcs",
		"body": [
		  "string lcs(string s1, string s2){",
		  "    int n=s1.size(), m=s2.size();",
		  "    vector<vector<int>> gr(n+1, vector<int>(m+1));",
		  "    ",
		  "    for(int i=1; i<=n; i++){",
		  "        for(int j=1; j<=m; j++){",
		  "            if(s1[i-1] == s2[j-1]){",
		  "                gr[i][j] = gr[i-1][j-1]+1;",
		  "            }else{",
		  "                gr[i][j] = max(gr[i][j-1], gr[i-1][j]);",
		  "            }",
		  "        }",
		  "    }",
		  "    int i=n, j=m;",
		  "    string ans = \"\";",
		  "    while(i>0 and j>0){",
		  "        if(s1[i-1] == s2[j-1]){",
		  "            ans.push_back(s1[i-1]);",
		  "            i--;",
		  "            j--;",
		  "        }else{",
		  "            if(gr[i-1][j] > gr[i][j-1]){",
		  "                i--;",
		  "            }else{",
		  "                j--;",
		  "            }",
		  "        }",
		  "    }",
		  "    reverse(ans.begin(), ans.end());",
		  "    return ans;",
		  "}"
		],
		"description": "longest common subsequence"
	},
	"competitive programming template": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"",
			"#define IO \t\t\tios_base::sync_with_stdio(false); cin.tie(NULL);cout << setprecision(12) << fixed;",
			"#define el \t\t\t\"\\n\"",
			"#define all(x) \t\tx.begin(), x.end()",
			"#define allr(x) \tx.rbegin(), x.rend()",
			"#define sum(v) \t\taccumulate(all(v), 0LL)",
			"#define int \t\tlong long int",
			"#define double \t\tlong double",
			"#define inf \t\tLLONG_MAX",
			"#define mod \t\t1e9+7",
			"#define MOD \t\t998244353",
			"#define vi \t\t\tvector<int>",
			"#define pi \t\t\tpair<int, int>",
			"#define vp \t\t\tvector<pair<int, int>>",
			"#define vvi \t\tvector<vi>",
			"",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"struct custom_hash {",
			"\tstatic uint64_t splitmix64(uint64_t x) {",
			"\t\t// http://xorshift.di.unimi.it/splitmix64.c",
			"\t\tx += 0x9e3779b97f4a7c15;",
			"\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"\t\treturn x ^ (x >> 31);",
			"\t}",
			"",
			"\tsize_t operator()(uint64_t x) const {",
			"\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"\t\treturn splitmix64(x + FIXED_RANDOM);",
			"\t}",
			"};",
			"",
			"template<class T> \t\t\tusing oset =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
			"template<class T, class V> \tusing omap =tree<T, V, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
			"template<class T> \t\t\tusing uset = unordered_set<T, custom_hash> ;",
			"template<class T, class V> \tusing umap = unordered_map<T, V, custom_hash> ;",
			"template<class T> \t\t\tusing umset = unordered_multiset<T, custom_hash> ;",
			"template<class T, class V> \tusing ummap = unordered_multimap<T, V, custom_hash> ;",
			"",
			"template<class T>           using mxpq = priority_queue<T>;",
			"template<class T>           using mnpq = priority_queue<T, vector<T>, greater<T> >;",
			"",
			"template<typename T1, typename T2>",
			"istream& operator>>(istream &istream, pair<T1, T2> &p) {return (istream >> p.first >> p.second); }",
			"",
			"template<typename T>",
			"istream& operator>>(istream &istream, vector<T> &v) { for(auto &e: v)cin >> e;return istream; }",
			"",
			"template<typename T1, typename T2>",
			"ostream& operator<<(ostream &ostream, pair<T1, T2> &p) {return (ostream << p.first << \" \" << p.second); }",
			"",
			"template<typename T>",
			"ostream& operator<<(ostream &ostream, vector<T> &v) { for(auto &e: v)cout << e << \" \";return ostream; }",
			"",
			"",
			"// Power under mod (a ^ b) % mod",
			"int modpow(int a, int b, int m = mod) {",
			"\tint ans = 1;",
			"\twhile (b) {",
			"\t\tif (b & 1) { ans = (ans * a) % m; }",
			"\t\tb = b >> 1; a = (a * a) % m;",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"// Inverse Mod (1 / a) % mod",
			"int modinv(int a, int m = mod) { return modpow(a, m - 2); }",
			"",
			"// Modular Arithematic",
			"int modadd(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a + b) % m) + m) % m; }",
			"int modsub(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a - b) % m) + m) % m; }",
			"int modmul(int a, int b, int m = mod) { a = a % m; b = b % m; return (((a * b) % m) + m) % m; }",
			"int moddiv(int a, int b, int m = mod) { a = a % m; b = b % m; return (modmul(a, modinv(b, m), m) + m) % m; }",
			"",
			"vector<bool>boolPrimeVec(1000001);vector<int> PrimeVec;void sieve(int n) {for (int i = 2; i <= n; i++)if (boolPrimeVec[i] == 0) {PrimeVec.push_back(i); for (int j = i*i; j <= n; j += i)boolPrimeVec[j] = 1;}}",
			"",
			"void presolve(){",
			"",
			"}",
			"",
			"void solve(){",
			"\t// cout << \"\\n=================================================\\n\";",
			"\t$1",
			"}",
			"",
			"/*",
			"\tif bruteforce can be done",
			"\tif binarySearch can be done",
			"\tcheck out of bound, keep extra bounds",
			"\tdont be afraid to use advanced dataStructures",
			"\ttry both top-down and bottom-up approach",
			"\tcan u find a pattern",
			"\t------",
			"\t",
			"\tdont forget 0LL",
			"*/",
			"",
			"int32_t main(){",
			"\tIO",
			"\tpresolve();",
			"\tint t;cin>>t;while(t--)",
			"\tsolve();",
			"\treturn 0;",
			"}",
			""
		],
		"description": "latest cp template"
	},

	"simple segment tree": {
		"prefix": "segtree",
		"body": [
		  "",
		  "template<class B> struct Segtree : public B {",
		  "    using T = typename B::T;",
		  "",
		  "    size_t n; vector<T> s;",
		  "    Segtree(size_t n) : n(n), s(2*n,B::e) {};",
		  "    ",
		  "    Segtree(vector<T> v){",
		  "        n = v.size();",
		  "        s.resize(2*n, B::e);",
		  "        for (int i = 0; i < n; i++)",
		  "            s[n + i] = v[i];   ",
		  " ",
		  "        for (int i = n - 1; i >= 1; i--)",
		  "            s[i] = B::op(s[2 * i], s[2 * i + 1]);",
		  "",
		  "    }",
		  "    ",
		  "    void update(int i, T val) {",
		  "        for (s[i += n] = val; i >>= 1;) s[i] = B::op(s[2*i],s[2*i+1]);",
		  "    }",
		  "",
		  "    T query(int l, int r) {",
		  "        T la = B::e, ra = B::e; ",
		  "        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
		  "            if (l & 1) la = B::op(la, s[l++]);",
		  "            if (r & 1) ra = B::op(s[--r], ra);",
		  "        }",
		  "        return B::op(la, ra);",
		  "    }",
		  "};",
		  "",
		  "struct MaxInt {",
		  "    using T = int;",
		  "    const T e = numeric_limits<int>::min();",
		  "    T op(T a, T b) { return max(a, b); }",
		  "};",
		  "",
		  "struct MinInt {",
		  "    using T = int;",
		  "    const T e = numeric_limits<int>::max();",
		  "    T op(T a, T b) { return min(a, b); }",
		  "};",
		  "",
		  "struct Sum {",
		  "    using T = int;",
		  "    const T e = 0LL;",
		  "    T op(T a, T b) { return a+b; }",
		  "};",
		  "",
		  "using MaxIntST = Segtree<MaxInt>;",
		  "using MinIntST = Segtree<MinInt>;",
		  "using SumST = Segtree<Sum>;",
		  ""
		],
		"description": "simple segment tree"
	  }
}


	  

